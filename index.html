<!doctype html>
<html lang="es">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Recursos: XML • JSON • AJAX • MVC • Spring Framework</title>
    <link rel="stylesheet" href="styles.css" />
</head>
<body>
    <aside class="sidebar">
        <div class="brand">
            <h1>Resumenes</h1>
            <p>XML · JSON · AJAX · MVC · Spring</p>
        </div>

        <nav class="navigation">
            <ul class="menu">
                <li><a href="#" data-section="resumen" class="menu-item active">XML</a></li>
                <li><a href="#" data-section="registrar-paciente" class="menu-item">JSON</a></li>
                <li><a href="#" data-section="gestionar-consultas" class="menu-item">AJAX</a></li>
                <li><a href="#" data-section="solicitar-analisis" class="menu-item">Modelo MVC</a></li>
                <li><a href="#" data-section="ver-resultados" class="menu-item">Spring Framework</a></li>
                <li><a href="#" data-section="archivos-paciente" class="menu-item">Comparativa y recursos</a></li>
                
            </ul>
        </nav>

        <footer class="sidebar-footer">
            <small>· Alvaro Rosso · 100318062 · LAB.Programacion III · Radhames Silverio Gonzalez</small>
        </footer>
    </aside>

    <main class="content">
    
        <section id="resumen" class="section active">
            <h2>XML</h2>
            <p>
                XML (Extensible Markup Language) es un formato de texto diseñado para almacenar y transportar datos de forma estructurada...
            </p>
            <!-- contenido: -->
            <article>
                <h3>Concepto y propósito</h3>
                <p>
                    XML es un lenguaje de marcado que pretende ser legible por humanos y máquinas. Su objetivo principal es describir datos —no su presentación— mediante etiquetas definidas por el usuario...
                </p>

                <h3>Características principales</h3>
                <ul>
                    <li>Auto-descriptivo: los nombres de las etiquetas describen el contenido.</li>
                    <li>Jerárquico: estructura en árbol que facilita el parseo y la validación.</li>
                    <li>Extensible: puedes crear tus propias etiquetas y esquemas.</li>
                    <li>Validación: DTD y XML Schema permiten verificar estructura y tipos.</li>
                </ul>

                <h3>Ventajas y desventajas</h3>
                <p>
                    <strong>Ventajas:</strong> interoperabilidad, independencia de plataforma, amplio soporte en bibliotecas y herramientas.<br/>
                    <strong>Desventajas:</strong> verborrea (más verborreico que JSON), mayor tamaño en texto plano, procesamiento generalmente más lento que formatos binarios.
                </p>

                <h3>Usos típicos</h3>
                <p>
                    Intercambio de datos entre sistemas heterogéneos, configuración (p. ej. archivos .pom.xml en Maven), servicios web SOAP, y almacenamiento temporal.
                </p>

                <h3>Ejemplo estático (Documento XML)</h3>
                <pre><code class="code">
<?xml version="1.0" encoding="UTF-8"?>
<hospital>
    <paciente id="P-001">
        <nombre>María Pérez</nombre>
        <documento tipo="cedula">001-0000001-0</documento>
        <fechaNacimiento>1985-04-12</fechaNacimiento>
        <alergias>
            <alergia>Penicilina</alergia>
        </alergias>
    </paciente>
    <estudio id="E-101">
        <nombre>Hemograma completo</nombre>
        <precio moneda="USD">25.00</precio>
    </estudio>
</hospital>
                </code></pre>

                <h3>Buenas prácticas</h3>
                <ol>
                    <li>Definir un esquema (XSD) para validar estructura y tipos.</li>
                    <li>Normalizar nombres de etiquetas y evitar espacios.</li>
                    <li>Usar espacios de nombres (namespaces) si se combinan vocabularios.</li>
                </ol>
            </article>
        </section>

        <section id="registrar-paciente" class="section">
            <h2>JSON — Extenso y ampliado</h2>
            <article>
                <h3>Qué es JSON y por qué se popularizó</h3>
                <p>
                    JSON (JavaScript Object Notation) es un formato ligero para intercambio de datos, basado en la sintaxis de objetos de JavaScript. Su simplicidad, tamaño reducido y compatibilidad con lenguajes modernos lo volvieron estándar en APIs REST y comunicaciones cliente-servidor.
                </p>

                <h3>Características</h3>
                <ul>
                    <li>Readable: sintaxis corta y consistente.</li>
                    <li>Estructuras: objetos (pares clave-valor) y arrays.</li>
                    <li>Tipado simple: cadenas, números, booleanos, null, objetos, arrays.</li>
                    <li>No tiene esquema obligatorio, pero existen JSON Schema para validación.</li>
                </ul>

                <h3>Ventajas y desventajas</h3>
                <p>
                    <strong>Ventajas:</strong> ligero, fácil de parsear en la mayoría de lenguajes, ideal para APIs REST.<br/>
                    <strong>Desventajas:</strong> ausencia de tipos avanzados, menor expresividad para metadatos complejos (en comparación con XML con XSD).
                </p>

                <h3>Usos típicos</h3>
                <p>
                    Comunicaciones HTTP REST, almacenamiento en bases de datos NoSQL (MongoDB, CouchDB), configuraciones ligeras, intercambios cliente/servidor en SPA.
                </p>

                <h3>Ejemplo estático (JSON)</h3>
                <pre><code class="code">
{
  "paciente": {
    "id": "P-001",
    "nombre": "María Pérez",
    "documento": {
      "tipo": "cedula",
      "numero": "001-0000001-0"
    },
    "fechaNacimiento": "1985-04-12",
    "alergias": ["Penicilina"]
  },
  "estudios": [
    {
      "id": "E-101",
      "nombre": "Hemograma completo",
      "precio": 25.00,
      "moneda": "USD"
    }
  ]
}
                </code></pre>

                <h3>Buenas prácticas</h3>
                <ul>
                    <li>Usar convenciones de nombrado consistentes (camelCase o snake_case).</li>
                    <li>Validar con JSON Schema en APIs públicas.</li>
                    <li>Evitar transportar datos innecesarios (minimizar payloads).</li>
                </ul>
            </article>
        </section>

        <section id="gestionar-consultas" class="section">
            <h2>AJAX — Extenso y ampliado</h2>
            <article>
                <h3>Definición y propósito</h3>
                <p>
                    AJAX (Asynchronous JavaScript and XML) es un conjunto de técnicas para realizar solicitudes asíncronas desde el navegador al servidor sin recargar la página completa. Aunque su nombre incluye XML, hoy en día JSON es el formato predominante.
                </p>

                <h3>Cómo funciona (concepto)</h3>
                <p>
                    El navegador realiza una llamada HTTP (GET/POST/etc.) en segundo plano; cuando la respuesta llega, el JavaScript procesa los datos y actualiza la interfaz DOM parcial. Esto mejora la experiencia de usuario y reduce tráfico.
                </p>

                <h3>Ventajas y desventajas</h3>
                <p>
                    <strong>Ventajas:</strong> experiencias más fluidas, reducción de recargas completas, mejor percepción de velocidad.<br/>
                    <strong>Desventajas:</strong> complejidad en manejo de estados, problemas de accesibilidad si no se gestiona la navegación correctamente, necesidades de manejo de errores y timeout.
                </p>

                <h3>Patrones modernos</h3>
                <p>
                    Hoy se usan `fetch()` y librerías (Axios, jQuery.ajax) o abstracciones (GraphQL) para gestionar solicitudes; también se combinan con promises, async/await y manejo de cancelación (AbortController).
                </p>

                <h3>Ejemplo estático (Solicitud AJAX - fetch)</h3>
                <pre><code class="code">
/* Ejemplo estático: petición GET que obtiene un JSON */
fetch('/api/pacientes/ P-001')
  .then(response =&gt; {
    if (!response.ok) throw new Error('Error en la petición');
    return response.json();
  })
  .then(data =&gt; {
    // Procesar el JSON (ESTE ES UN EJEMPLO ESTÁTICO: no ejecutable aquí)
    console.log('Paciente:', data);
  })
  .catch(err =&gt; console.error(err));
                </code></pre>

                <h3>Buenas prácticas</h3>
                <ul>
                    <li>Gestionar errores y estados de red (retry/backoff) para operaciones críticas.</li>
                    <li>Usar HTTPS y tokens/headers apropiados para seguridad.</li>
                    <li>Evitar bloquear la UI y mostrar indicadores de carga.</li>
                </ul>
            </article>
        </section>

        <section id="solicitar-analisis" class="section">
            <h2>Modelo MVC — Extenso y ampliado</h2>
            <article>
                <h3>Descripción general</h3>
                <p>
                    MVC (Model-View-Controller) es un patrón arquitectónico que separa la lógica de negocio (Model), la presentación (View) y el control de flujo (Controller). Su objetivo es modularidad, separación de responsabilidades y testabilidad.
                </p>

                <h3>Componentes</h3>
                <ul>
                    <li><strong>Model:</strong> representa datos y reglas de negocio. Puede comunicarse con la base de datos y validar la lógica.</li>
                    <li><strong>View:</strong> responsable de la presentación (HTML/CSS). Recibe datos del controlador o del modelo y los muestra.</li>
                    <li><strong>Controller:</strong> recibe las entradas del usuario (requests), invoca lógica en el modelo y determina la vista que se debe renderizar.</li>
                </ul>

                <h3>Flujo típico</h3>
                <p>
                    1) El usuario hace una petición → 2) Controller interpreta la petición → 3) Controller consulta/manipula Model → 4) Model devuelve datos → 5) Controller selecciona View y entrega datos → 6) View renderiza la respuesta.
                </p>

                <h3>Ventajas y desventajas</h3>
                <p>
                    <strong>Ventajas:</strong> mayor mantenibilidad, mejor separación de responsabilidades, facilita pruebas unitarias y desarrollo paralelo.<br/>
                    <strong>Desventajas:</strong> puede introducir complejidad y sobreingeniería en aplicaciones muy pequeñas; diseños incorrectos pueden provocar acoplamiento si no se respetan las fronteras.
                </p>

                <h3>Ejemplo estático (diagrama textual / pseudocódigo)</h3>
                <pre><code class="code">
/* Controller (pseudocódigo) */
class PacienteController {
  function mostrar(id) {
    paciente = PacienteModel.buscarPorId(id);
    return View.render('paciente_detalle', { paciente: paciente });
  }
}

/* Model (pseudocódigo) */
class PacienteModel {
  static function buscarPorId(id) { /* consulta DB y retorna objeto */ }
}

/* View: plantilla HTML que recibe 'paciente' y muestra sus campos */
                </code></pre>

                <h3>Patrones relacionados</h3>
                <p>
                    MVP, MVVM y arquitecturas hexagonales o de capas. En aplicaciones web modernas MVC se combina con SPA donde la parte View se vuelve dinámica (client-side frameworks).
                </p>
            </article>
        </section>

        <section id="ver-resultados" class="section">
            <h2>Spring Framework — Extenso y ampliado</h2>
            <article>
                <h3>Introducción</h3>
                <p>
                    Spring es un framework para la plataforma Java que facilita el desarrollo de aplicaciones empresariales mediante inversión de control (IoC), inyección de dependencias (DI), programación orientada a aspectos (AOP) y un amplio ecosistema (Spring Boot, Spring Data, Spring MVC, Spring Security).
                </p>

                <h3>Funcionalidades principales</h3>
                <ul>
                    <li><strong>IoC / DI:</strong> gestión del ciclo de vida y resolución de dependencias mediante contenedor.</li>
                    <li><strong>Spring MVC:</strong> marco para aplicaciones web basadas en controlador/plantilla.</li>
                    <li><strong>Spring Boot:</strong> arranque rápido con convenciones, auto-configuración y servidor embebido.</li>
                    <li><strong>Spring Data:</strong> abstracciones para acceso a datos (JPA, MongoDB, Redis).</li>
                    <li><strong>Spring Security:</strong> seguridad robusta: autenticación, autorización, OAuth2, JWT.</li>
                    <li><strong>Transacciones declarativas:</strong> manejo de transacciones mediante anotaciones.</li>
                    <li><strong>Integración y mensajería:</strong> Spring Integration, Spring Kafka, etc.</li>
                    <li><strong>Testabilidad:</strong> utilidades para tests unitarios e integración (slicing, contexto de prueba).</li>
                </ul>

                <h3>Arquitectura y beneficios</h3>
                <p>
                    Spring promueve aplicaciones modulares y desacopladas. Spring Boot reduce la complejidad de configuración y acelera la entrega. El ecosistema soporta desde microservicios hasta aplicaciones monolíticas con necesidades empresariales complejas.
                </p>

                <h3>Ventajas y desventajas</h3>
                <p>
                    <strong>Ventajas:</strong> madurez, comunidad grande, muchas integraciones, productividad con Spring Boot.<br/>
                    <strong>Desventajas:</strong> curva de aprendizaje (conceptos como contexto, scopes, proxies), overhead inicial en aplicaciones muy simples.
                </p>

                <h3>Ejemplo estático (Controlador Spring Boot)</h3>
                <pre><code class="code">
/* Ejemplo estático en Java (Spring Boot) */
@RestController
@RequestMapping("/api/pacientes")
public class PacienteController {

    private final PacienteService pacienteService;

    public PacienteController(PacienteService pacienteService) {
        this.pacienteService = pacienteService;
    }

    @GetMapping("/{id}")
    public ResponseEntity&lt;PacienteDto&gt; obtener(@PathVariable String id) {
        PacienteDto dto = pacienteService.buscarPorId(id);
        return ResponseEntity.ok(dto);
    }
}
                </code></pre>

                <h3>Buenas prácticas al usar Spring</h3>
                <ul>
                    <li>Preferir inyección de dependencias por constructor.</li>
                    <li>Externalizar configuración (application.yml/properties).</li>
                    <li>Usar perfiles (dev/test/prod) y pruebas de integración con contextos acotados.</li>
                    <li>Monitoreo y trazabilidad (Actuator, micrometer, logs estructurados).</li>
                </ul>

                <h3>Conclusión</h3>
                <p>
                    Spring es la opción madura para proyectos Java de alcance medio a grande, ofreciendo un ecosistema que cubre seguridad, datos, integración y despliegue, con especial potencia al combinar Spring Boot y las abstracciones de Spring Data y Spring Security.
                </p>
            </article>
        </section>

        <section id="archivos-paciente" class="section">
            <h2>Comparativa y recursos</h2>
            <article>
                <h3>Comparativa resumida</h3>
                <table class="compare">
                    <thead>
                        <tr><th>Tema</th><th>Formato/uso</th><th>Ventaja clave</th></tr>
                    </thead>
                    <tbody>
                        <tr><td>XML</td><td>Documento jerárquico, schemas (XSD)</td><td>Rico en metadatos y validación</td></tr>
                        <tr><td>JSON</td><td>Objeto/array ligero</td><td>Ligero y rápido para APIs</td></tr>
                        <tr><td>AJAX</td><td>Comunicación asíncrona</td><td>UX fluida sin recargas</td></tr>
                        <tr><td>MVC</td><td>Patrón arquitectónico</td><td>Separación de responsabilidades</td></tr>
                        <tr><td>Spring</td><td>Framework Java empresarial</td><td>Amplio ecosistema integrado</td></tr>
                    </tbody>
                </table>

                <h3>Enlaces de interés (sugeridos)</h3>
                <ul>
                    <li>Documentación oficial de Spring (buscar "Spring Framework docs").</li>
                    <li>Especificaciones de XML Schema y W3C.</li>
                    <li>JSON Schema para validación.</li>
                </ul>
            </article>
        </section>
    </main>

    <script src="script.js"></script>
</body>
</html>
